/*
Roi_dev

Your custom SDK

API version: Roi_dev: v9 SDK
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package snapser

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// InventoryServiceApiService InventoryServiceApi service
type InventoryServiceApiService service

type ApiConsumeItemRequest struct {
	ctx        context.Context
	ApiService *InventoryServiceApiService
	userId     string
	instanceId string
	token      *string
	body       *ConsumeItemRequest
}

// User session token
func (r ApiConsumeItemRequest) Token(token string) ApiConsumeItemRequest {
	r.token = &token
	return r
}

func (r ApiConsumeItemRequest) Body(body ConsumeItemRequest) ApiConsumeItemRequest {
	r.body = &body
	return r
}

func (r ApiConsumeItemRequest) Execute() (*InventoryConsumeItemResponse, *http.Response, error) {
	return r.ApiService.ConsumeItemExecute(r)
}

/*
ConsumeItem Consume item from inventory

Consumes item from user inventory by a count given an instance id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Id of affected user
	@param instanceId Id of the item present in user inventory
	@return ApiConsumeItemRequest
*/
func (a *InventoryServiceApiService) ConsumeItem(ctx context.Context, userId string, instanceId string) ApiConsumeItemRequest {
	return ApiConsumeItemRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return	InventoryConsumeItemResponse
func (a *InventoryServiceApiService) ConsumeItemExecute(r ApiConsumeItemRequest) (*InventoryConsumeItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InventoryConsumeItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryServiceApiService.ConsumeItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory/users/{user_id}/items/{instance_id}/consume"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instance_id"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Token"] = parameterToString(*r.token, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteUserItemRequest struct {
	ctx        context.Context
	ApiService *InventoryServiceApiService
	userId     string
	instanceId string
	token      *string
}

// User session token
func (r ApiDeleteUserItemRequest) Token(token string) ApiDeleteUserItemRequest {
	r.token = &token
	return r
}

func (r ApiDeleteUserItemRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteUserItemExecute(r)
}

/*
DeleteUserItem User Inventory Item

Deletes item from user inventory given instance id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Id of user from which item would be removed
	@param instanceId Id of the item present in user inventory
	@return ApiDeleteUserItemRequest
*/
func (a *InventoryServiceApiService) DeleteUserItem(ctx context.Context, userId string, instanceId string) ApiDeleteUserItemRequest {
	return ApiDeleteUserItemRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return	map[string]interface{}
func (a *InventoryServiceApiService) DeleteUserItemExecute(r ApiDeleteUserItemRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryServiceApiService.DeleteUserItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory/users/{user_id}/items/{instance_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instance_id"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Token"] = parameterToString(*r.token, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllUserItemsRequest struct {
	ctx             context.Context
	ApiService      *InventoryServiceApiService
	userId          string
	token           *string
	limit           *int32
	offset          *int32
	catalogItemName *string
}

// User session token
func (r ApiGetAllUserItemsRequest) Token(token string) ApiGetAllUserItemsRequest {
	r.token = &token
	return r
}

// limit, max number of items in the response, defaults to x
func (r ApiGetAllUserItemsRequest) Limit(limit int32) ApiGetAllUserItemsRequest {
	r.limit = &limit
	return r
}

// offset, defaults to zero
func (r ApiGetAllUserItemsRequest) Offset(offset int32) ApiGetAllUserItemsRequest {
	r.offset = &offset
	return r
}

// filter items by catalog_item_name
func (r ApiGetAllUserItemsRequest) CatalogItemName(catalogItemName string) ApiGetAllUserItemsRequest {
	r.catalogItemName = &catalogItemName
	return r
}

func (r ApiGetAllUserItemsRequest) Execute() (*InventoryGetUserItemsResponse, *http.Response, error) {
	return r.ApiService.GetAllUserItemsExecute(r)
}

/*
GetAllUserItems Get Items

Gets items from inventory in pages. Default page size is x

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId userid to assign the items
	@return ApiGetAllUserItemsRequest
*/
func (a *InventoryServiceApiService) GetAllUserItems(ctx context.Context, userId string) ApiGetAllUserItemsRequest {
	return ApiGetAllUserItemsRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return	InventoryGetUserItemsResponse
func (a *InventoryServiceApiService) GetAllUserItemsExecute(r ApiGetAllUserItemsRequest) (*InventoryGetUserItemsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InventoryGetUserItemsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryServiceApiService.GetAllUserItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory/users/{user_id}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.catalogItemName != nil {
		localVarQueryParams.Add("catalog_item_name", parameterToString(*r.catalogItemName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Token"] = parameterToString(*r.token, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserCurrenciesRequest struct {
	ctx        context.Context
	ApiService *InventoryServiceApiService
	userId     string
	token      *string
}

// User session token
func (r ApiGetUserCurrenciesRequest) Token(token string) ApiGetUserCurrenciesRequest {
	r.token = &token
	return r
}

func (r ApiGetUserCurrenciesRequest) Execute() (*InventoryGetUserCurrenciesResponse, *http.Response, error) {
	return r.ApiService.GetUserCurrenciesExecute(r)
}

/*
GetUserCurrencies Get User Currencies

Get user currencies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId User id
	@return ApiGetUserCurrenciesRequest
*/
func (a *InventoryServiceApiService) GetUserCurrencies(ctx context.Context, userId string) ApiGetUserCurrenciesRequest {
	return ApiGetUserCurrenciesRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return	InventoryGetUserCurrenciesResponse
func (a *InventoryServiceApiService) GetUserCurrenciesExecute(r ApiGetUserCurrenciesRequest) (*InventoryGetUserCurrenciesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InventoryGetUserCurrenciesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryServiceApiService.GetUserCurrencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory/user/{user_id}/currencies"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Token"] = parameterToString(*r.token, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserItemRequest struct {
	ctx        context.Context
	ApiService *InventoryServiceApiService
	userId     string
	instanceId string
	token      *string
}

// User session token
func (r ApiGetUserItemRequest) Token(token string) ApiGetUserItemRequest {
	r.token = &token
	return r
}

func (r ApiGetUserItemRequest) Execute() (*InventoryUserInventoryItem, *http.Response, error) {
	return r.ApiService.GetUserItemExecute(r)
}

/*
GetUserItem User Inventory Item

Gets item from inventory given instance id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Id of affected user
	@param instanceId Id of the item present in user inventory
	@return ApiGetUserItemRequest
*/
func (a *InventoryServiceApiService) GetUserItem(ctx context.Context, userId string, instanceId string) ApiGetUserItemRequest {
	return ApiGetUserItemRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return	InventoryUserInventoryItem
func (a *InventoryServiceApiService) GetUserItemExecute(r ApiGetUserItemRequest) (*InventoryUserInventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InventoryUserInventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryServiceApiService.GetUserItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory/users/{user_id}/items/{instance_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instance_id"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Token"] = parameterToString(*r.token, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGrantItemsToUserRequest struct {
	ctx        context.Context
	ApiService *InventoryServiceApiService
	userId     string
	token      *string
	body       *GrantItemsToUserRequest
}

// User session token
func (r ApiGrantItemsToUserRequest) Token(token string) ApiGrantItemsToUserRequest {
	r.token = &token
	return r
}

func (r ApiGrantItemsToUserRequest) Body(body GrantItemsToUserRequest) ApiGrantItemsToUserRequest {
	r.body = &body
	return r
}

func (r ApiGrantItemsToUserRequest) Execute() (*InventoryUserInventory, *http.Response, error) {
	return r.ApiService.GrantItemsToUserExecute(r)
}

/*
GrantItemsToUser Grant Item

Grants the list of items to user, this does not modify currencies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Id of user receiving the assets
	@return ApiGrantItemsToUserRequest
*/
func (a *InventoryServiceApiService) GrantItemsToUser(ctx context.Context, userId string) ApiGrantItemsToUserRequest {
	return ApiGrantItemsToUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return	InventoryUserInventory
func (a *InventoryServiceApiService) GrantItemsToUserExecute(r ApiGrantItemsToUserRequest) (*InventoryUserInventory, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InventoryUserInventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryServiceApiService.GrantItemsToUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory/users/{user_id}/items/grant"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Token"] = parameterToString(*r.token, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPurchaseItemWithVirtualCurrencyRequest struct {
	ctx        context.Context
	ApiService *InventoryServiceApiService
	userId     string
	token      *string
	body       *PurchaseItemWithVirtualCurrencyRequest
}

// User session token
func (r ApiPurchaseItemWithVirtualCurrencyRequest) Token(token string) ApiPurchaseItemWithVirtualCurrencyRequest {
	r.token = &token
	return r
}

func (r ApiPurchaseItemWithVirtualCurrencyRequest) Body(body PurchaseItemWithVirtualCurrencyRequest) ApiPurchaseItemWithVirtualCurrencyRequest {
	r.body = &body
	return r
}

func (r ApiPurchaseItemWithVirtualCurrencyRequest) Execute() (*InventoryUserInventoryItem, *http.Response, error) {
	return r.ApiService.PurchaseItemWithVirtualCurrencyExecute(r)
}

/*
PurchaseItemWithVirtualCurrency Purchase Item with Virtual Currency

Purchase an item with given virtual currency

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Id of user receiving the assets
	@return ApiPurchaseItemWithVirtualCurrencyRequest
*/
func (a *InventoryServiceApiService) PurchaseItemWithVirtualCurrency(ctx context.Context, userId string) ApiPurchaseItemWithVirtualCurrencyRequest {
	return ApiPurchaseItemWithVirtualCurrencyRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return	InventoryUserInventoryItem
func (a *InventoryServiceApiService) PurchaseItemWithVirtualCurrencyExecute(r ApiPurchaseItemWithVirtualCurrencyRequest) (*InventoryUserInventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InventoryUserInventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryServiceApiService.PurchaseItemWithVirtualCurrency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory/users/{user_id}/items/purchase"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Token"] = parameterToString(*r.token, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnlockContainerRequest struct {
	ctx        context.Context
	ApiService *InventoryServiceApiService
	userId     string
	instanceId string
	token      *string
	body       *UnlockContainerRequest
}

// User session token
func (r ApiUnlockContainerRequest) Token(token string) ApiUnlockContainerRequest {
	r.token = &token
	return r
}

func (r ApiUnlockContainerRequest) Body(body UnlockContainerRequest) ApiUnlockContainerRequest {
	r.body = &body
	return r
}

func (r ApiUnlockContainerRequest) Execute() (*InventoryUnlockContainerResponse, *http.Response, error) {
	return r.ApiService.UnlockContainerExecute(r)
}

/*
UnlockContainer Unlock Container

Unlocks a container item from user inventory given an instance id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Id of affected user
	@param instanceId Id of the container present in user inventory
	@return ApiUnlockContainerRequest
*/
func (a *InventoryServiceApiService) UnlockContainer(ctx context.Context, userId string, instanceId string) ApiUnlockContainerRequest {
	return ApiUnlockContainerRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return	InventoryUnlockContainerResponse
func (a *InventoryServiceApiService) UnlockContainerExecute(r ApiUnlockContainerRequest) (*InventoryUnlockContainerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InventoryUnlockContainerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryServiceApiService.UnlockContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory/users/{user_id}/items/{instance_id}/unlock"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instance_id"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Token"] = parameterToString(*r.token, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserItemMetadataRequest struct {
	ctx        context.Context
	ApiService *InventoryServiceApiService
	userId     string
	instanceId string
	token      *string
	body       *UpdateUserItemMetadataRequest
}

// User session token
func (r ApiUpdateUserItemMetadataRequest) Token(token string) ApiUpdateUserItemMetadataRequest {
	r.token = &token
	return r
}

func (r ApiUpdateUserItemMetadataRequest) Body(body UpdateUserItemMetadataRequest) ApiUpdateUserItemMetadataRequest {
	r.body = &body
	return r
}

func (r ApiUpdateUserItemMetadataRequest) Execute() (*InventoryUserInventoryItem, *http.Response, error) {
	return r.ApiService.UpdateUserItemMetadataExecute(r)
}

/*
UpdateUserItemMetadata User Inventory Item

Update the metadata of the user inventory item. Not to be confused with catalog item metadata

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Id of affected user
	@param instanceId Id of the item present in user inventory
	@return ApiUpdateUserItemMetadataRequest
*/
func (a *InventoryServiceApiService) UpdateUserItemMetadata(ctx context.Context, userId string, instanceId string) ApiUpdateUserItemMetadataRequest {
	return ApiUpdateUserItemMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return	InventoryUserInventoryItem
func (a *InventoryServiceApiService) UpdateUserItemMetadataExecute(r ApiUpdateUserItemMetadataRequest) (*InventoryUserInventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InventoryUserInventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryServiceApiService.UpdateUserItemMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory/users/{user_id}/items/{instance_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instance_id"+"}", url.PathEscape(parameterToString(r.instanceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Token"] = parameterToString(*r.token, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserVirtualCurrencyRequest struct {
	ctx          context.Context
	ApiService   *InventoryServiceApiService
	userId       string
	currencyName string
	token        *string
	body         *UpdateUserVirtualCurrencyRequest
}

// User session token
func (r ApiUpdateUserVirtualCurrencyRequest) Token(token string) ApiUpdateUserVirtualCurrencyRequest {
	r.token = &token
	return r
}

func (r ApiUpdateUserVirtualCurrencyRequest) Body(body UpdateUserVirtualCurrencyRequest) ApiUpdateUserVirtualCurrencyRequest {
	r.body = &body
	return r
}

func (r ApiUpdateUserVirtualCurrencyRequest) Execute() (*InventoryUpdateUserVirtualCurrencyResponse, *http.Response, error) {
	return r.ApiService.UpdateUserVirtualCurrencyExecute(r)
}

/*
UpdateUserVirtualCurrency Add Virtual Currency

Add virtual currency to user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId Id of affected user
	@param currencyName Name of currency to be granted
	@return ApiUpdateUserVirtualCurrencyRequest
*/
func (a *InventoryServiceApiService) UpdateUserVirtualCurrency(ctx context.Context, userId string, currencyName string) ApiUpdateUserVirtualCurrencyRequest {
	return ApiUpdateUserVirtualCurrencyRequest{
		ApiService:   a,
		ctx:          ctx,
		userId:       userId,
		currencyName: currencyName,
	}
}

// Execute executes the request
//
//	@return	InventoryUpdateUserVirtualCurrencyResponse
func (a *InventoryServiceApiService) UpdateUserVirtualCurrencyExecute(r ApiUpdateUserVirtualCurrencyRequest) (*InventoryUpdateUserVirtualCurrencyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InventoryUpdateUserVirtualCurrencyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryServiceApiService.UpdateUserVirtualCurrency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inventory/user/{user_id}/currencies/{currency_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"currency_name"+"}", url.PathEscape(parameterToString(r.currencyName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Token"] = parameterToString(*r.token, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
